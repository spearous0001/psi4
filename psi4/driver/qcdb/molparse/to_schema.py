import json

import numpy as np

from ..util import unnp
from ..physconst import psi_bohr2angstroms


def to_schema(molrec, dtype, units='Angstrom', return_type='json'):
    """Translate Psi4 json Molecule spec into json from other schemas.

    Parameters
    ----------
    molrec : dict
        Psi4 json Molecule spec.
    dtype : {'psi4', 'v0.1'}
        Molecule schema format.
    units : {'Angstrom', 'Bohr'}
        Units in which to write string. There is not an option to write in
        intrinsic/input units. Some `dtype` may not allow all units.
    return_type : {'json', 'yaml'}
        Serialization format string to return.

    Returns
    -------
    qcschema : str
        String of the `return_type` repr of `molrec`.

    """
    qcschema = {}

    if molrec['units'] == 'Angstrom' and units == 'Angstrom':
        factor = 1.
    elif molrec['units'] == 'Angstrom' and units == 'Bohr':
        if 'input_units_to_au' in molrec:
            factor = molrec['input_units_to_au']
        else:
            factor = 1. / psi_bohr2angstroms
    elif molrec['units'] == 'Bohr' and units == 'Angstrom':
        factor = psi_bohr2angstroms
    elif molrec['units'] == 'Bohr' and units == 'Bohr':
        factor = 1.
    else:
        raise ValidationError("""units must be 'Angstrom'/'Bohr', not {}""".format(units))
    geom = np.array(molrec['geom']) * factor
    nat = geom.shape[0] // 3

    name = molrec.get('name', formula_generator(molrec['elem']))
#    tagline = """auto-generated by qcdb from molecule {}""".format(name)

    if dtype == 'psi4':
        qcschema = copy.deepcopy(molrec)
        qcschema['geom'] = geom
        qcschema['units'] = units
        qcschema['name'] = name

    elif dtype == 'v0.1':
        if units != 'Bohr':
            raise ValidationError("""QC_JSON_Schema {} allows only 'Bohr' coordinates, not {}.""".format(dtype, units))

        qcschema['symbols'] = np.array(molrec['elem'])
        qcschema['geometry'] = geom
        qcschema['masses'] = np.array(molrec['mass'])
        qcschema['name'] = name
        qcschema['molecular_charge'] = molrec['molecular_charge']
        qcschema['molecular_multiplicity'] = molrec['molecular_multiplicity']
        qcschema['real'] = np.array(molrec['real'])
        fidx = np.split(np.arange(nat), molrec['fragment_separators'])
        qcschema['fragments'] = [fr.tolist() for fr in fidx]
        qcschema['fragment_charges'] = np.array(molrec['fragment_charges'])
        qcschema['fragment_multiplicities'] = np.array(molrec['fragment_multiplicities'])
        qcschema['fix_com'] = molrec['fix_com']
        qcschema['fix_orientation'] = molrec['fix_orientation']

        # hmm, psi4/qcdb for provenance or does psi molrec need a passthrough field to preserve?
        #qcschema['provenance'] creator, version, routine

    qcschema = unnp(qcschema)

    if return_type == 'json':
        return json.dumps(qcschema)
    elif return_type == 'yaml':
        import yaml
        return yaml.dump(qcschema)
    else:
        raise ValidationError("""Return type ({}) not recognized.""".format(return_type))
